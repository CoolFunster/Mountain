7/31

Ok so recursion is done now. What's next

- Higher category definition & fixes
- refinement categories
- fixing and deleting MTPLExpressionX
- What is type operations?
- How do we integrate specialized higher category solvers?
- Subtractive category

I think we should focus on higher categories

A higher category is the type operator. Its a thing which groups categories together into 
something that is a higher level than the inner categories

There are 3 ways to make a type (aka increase the level of objects):
1 - define a recursive category (recursion)
2 - Group specific things together (higher)
3 - Define a property as a type (refined)

So a higher category is a category which has any category whose basic building blocks are the elements of the higher category.

That means if i can find a "proof" or a "function" from the elements of the higher category to the elements of the other, its an element

But not every higher category is decidable. function calls and other things may be difficult. Which means that
the user has to supply their own decidability thing or use the generic one. Also that the proof engine will have to
be knowledgeable about those methods

Ok so higher categories use proofs to determine whether they have something. 

Ok so next step is to remove MTPL expression stuff and get the sequent proof engine working on the base category level,
eventually so that it can be used in the has for higher categories


A higher category should be isomorphic to a theory
a theory has
    - things 
    - functions
    - properties
    - axioms

a higher category will express these things by
    - things =      categorical things
    - functions =   categorical morphisms
    - properties =  categorical morphisms of type (input) -> Bool
    - axioms =      categorical refined categories & algebraic data types

so its just a collection of categorical objects and not language constructs or flexible categories

===========
Grocery App
===========
    Ingredients <
        Thing (Name "Pepper")
        Thing (Name "Salt")
        Thing (Name "Egg")
        Thing (Name "Milk")
        Thing (Name "Flour")
    >

    Location : (long:Float, lat:Float) -- can be ints initially

    Ingredient Store : ({Ingredients}, Location)

    Recipe : [Ingredients]

    Graphs : Sumposition (predecessor:Location -> Sumposition(successor:Location -> {dist:Float | dist > 0.0}))

    Route
        {r@(edges:[(pred:Location,succ:Location)], m:Map) | for each edge in edges : ((x:Any,y:Any) -> x `elem` m && y `elem` m(x)}

    Length: r@Route -> Int :: foldr(0, r.edges,(state, (pred,succ)) -> state + r.m(pred)(succ))

    Location -> RoutePlanner
        map : Map -> locations:[Location] -> {r:Route | minimized(Length(r))}

    GroceryRoute : [([Ingredients], IngredientStore)]

    GroceryApp :
        r:Recipe -> {r:GroceryRoute | recipe == foldr({}, r, (state, (ing:{Ingredients}, IngredientStore)) -> state insert ing)}

    


Notes:

Key basic morphisms that need to be published to the language
    has
    morphism dereference with head/tail
    Input valid for morphism
    optimization objective
Lists are critical to define (can be morphisms)
    looping over Lists
    foldr? foldl?
    transformations, filtering?
Graphs are also critical to the grocery app for the route planner
    algebraic graphs

Refinement is also critical to hold specifications. How to verify?

Sets are also crucial to define as a basic data structure for performance

How to populate types from databases

placeholder and refinement = current placeholder
